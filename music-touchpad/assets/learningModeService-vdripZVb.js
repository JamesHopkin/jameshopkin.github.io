class u{tempo;currentBeat=0;isPaused=!1;lastTickTime=0;metronomeStartTime=0;metronomeBeat=0;songStartBeat=0;isRunning=!1;animationFrameId=null;scheduledEvents=[];nextEventId=0;audioContext=null;clickEnabled=!0;clickVolume=.5;timeSignature={beatsPerBar:4,beatUnit:4};lookAheadTime=.1;lastScheduledMetronomeBeat=-1;scheduledOscillators=[];constructor(e=120,t){this.tempo=e,this.audioContext=t||null}start(){if(!this.isRunning){for(const e of this.scheduledOscillators)try{e.stop(),e.disconnect()}catch{}this.scheduledOscillators=[],this.isRunning=!0,this.isPaused=!1,this.lastTickTime=performance.now(),this.currentBeat=0,this.metronomeBeat=0,this.songStartBeat=0,this.lastScheduledMetronomeBeat=-1,this.audioContext&&(this.metronomeStartTime=this.audioContext.currentTime),this.scheduleNextFrame()}}stop(){if(this.isRunning){this.isRunning=!1,this.isPaused=!1,this.animationFrameId!==null&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null);for(const e of this.scheduledOscillators)try{e.stop(),e.disconnect()}catch{}this.scheduledOscillators=[],this.scheduledEvents=[],this.metronomeBeat=0,this.songStartBeat=0,this.lastScheduledMetronomeBeat=-1,console.log("Metronome stopped and all audio clicks cancelled")}}pause(){!this.isRunning||this.isPaused||(this.isPaused=!0,console.log("Learning mode clock paused at beat",this.currentBeat.toFixed(3)),console.log("Metronome clock continues running"))}resume(){if(!(!this.isRunning||!this.isPaused))if(this.isPaused=!1,this.lastTickTime=performance.now(),this.audioContext){const e=(this.audioContext.currentTime-this.metronomeStartTime)/(60/this.tempo);this.songStartBeat=e-this.currentBeat,console.log(`Learning mode clock resumed at beat ${this.currentBeat.toFixed(3)}, syncing downbeats (offset: ${this.songStartBeat.toFixed(3)})`)}else console.log("Learning mode clock resumed at beat",this.currentBeat.toFixed(3))}reset(){for(const e of this.scheduledOscillators)try{e.stop(),e.disconnect()}catch{}this.scheduledOscillators=[],this.currentBeat=0,this.metronomeBeat=0,this.songStartBeat=0,this.lastScheduledMetronomeBeat=-1,this.lastTickTime=performance.now(),this.scheduledEvents=[],this.audioContext&&(this.metronomeStartTime=this.audioContext.currentTime)}scheduleAt(e,t,s){const o=s||`event-${this.nextEventId++}`,i={beat:e,callback:t,id:o},n=this.scheduledEvents.findIndex(a=>a.beat>e);return n===-1?this.scheduledEvents.push(i):this.scheduledEvents.splice(n,0,i),o}cancelScheduledEvent(e){const t=this.scheduledEvents.findIndex(s=>s.id===e);return t!==-1?(this.scheduledEvents.splice(t,1),!0):!1}getCurrentBeat(){return this.currentBeat}setTempo(e){this.tempo=e}getTempo(){return this.tempo}isPlaying(){return this.isRunning}scheduleNextFrame(){this.isRunning&&(this.animationFrameId=requestAnimationFrame(e=>{this.tick(e),this.scheduleNextFrame()}))}tick(e){if(this.scheduleMetronomeClicks(),this.isPaused)this.lastTickTime=e;else{const t=e,s=t-this.lastTickTime;this.lastTickTime=t;const o=s/1e3*(this.tempo/60);for(this.currentBeat+=o;this.scheduledEvents.length>0&&this.scheduledEvents[0].beat<=this.currentBeat;){const i=this.scheduledEvents.shift();try{i.callback()}catch(n){console.error("Error in scheduled event callback:",n)}}}}scheduleMetronomeClicks(){if(!this.audioContext||!this.clickEnabled)return;const e=this.audioContext.currentTime,t=60/this.tempo,s=Math.floor((e-this.metronomeStartTime)/t);for(let o=Math.max(s,this.lastScheduledMetronomeBeat+1);o<=s+Math.ceil(this.lookAheadTime/t);o++){const i=this.metronomeStartTime+o*t;if(i>=e&&i<e+this.lookAheadTime){const n=o-this.songStartBeat,r=Math.floor(n)%this.timeSignature.beatsPerBar===0;this.scheduleClickAt(i,r),this.lastScheduledMetronomeBeat=o}}}scheduleClickAt(e,t){if(!this.audioContext||!this.clickEnabled)return;const s=this.audioContext.createOscillator(),o=this.audioContext.createGain();s.connect(o),o.connect(this.audioContext.destination),s.frequency.value=t?1200:800,o.gain.setValueAtTime(this.clickVolume*.5,e),o.gain.exponentialRampToValueAtTime(.01,e+.05),this.scheduledOscillators.push(s),s.onended=()=>{const i=this.scheduledOscillators.indexOf(s);i!==-1&&this.scheduledOscillators.splice(i,1)},s.start(e),s.stop(e+.05)}setAudioContext(e){this.audioContext=e}setClickEnabled(e){this.clickEnabled=e,console.log(`Metronome clicks ${e?"enabled":"disabled"}`)}isClickEnabled(){return this.clickEnabled}setClickVolume(e){this.clickVolume=Math.max(0,Math.min(1,e))}getClickVolume(){return this.clickVolume}setTimeSignature(e,t){this.timeSignature={beatsPerBar:e,beatUnit:t},console.log(`Time signature set to ${e}/${t}`)}getTimeSignature(){return{...this.timeSignature}}}class m{metronome;grid;notes=[];currentNoteIndex=0;isActive=!1;_playingArea=[];state="IDLE";currentNote=null;activeNoteIndices=new Set;scheduleAheadCount=4;scheduledNoteIndices=new Set;timingToleranceBeats=.1;cueLeadTimeBeats=.2;currentLoopIteration=0;pressedNotesInChord=new Set;constructor(e,t=120,s=[],o){this.grid=e,this.metronome=new u(t,o),this._playingArea=s}loadLesson(e){this.notes=e,this.currentNoteIndex=0,this.scheduledNoteIndices.clear(),this.state="IDLE",this.currentNote=null,this.currentLoopIteration=0}start(){this.isActive||this.notes.length===0||(this.isActive=!0,this.currentNoteIndex=0,this.scheduledNoteIndices.clear(),this.currentLoopIteration=0,this.grid.clearAllCuePads(),this.metronome.reset(),this.metronome.start(),this.scheduleNextNotes())}stop(){this.isActive&&(this.isActive=!1,this.metronome.stop(),this.grid.clearAllCuePads(),this.currentNoteIndex=0,this.scheduledNoteIndices.clear(),this.state="IDLE",this.currentNote=null)}scheduleNextNotes(){if(this.isActive)for(;this.scheduledNoteIndices.size<this.scheduleAheadCount;){let e=-1;for(let s=0;s<this.notes.length;s++){const o=(this.currentNoteIndex+s)%this.notes.length;if(!this.scheduledNoteIndices.has(o)){e=o;break}}if(e===-1)break;const t=this.notes[e];if(t.isRest){console.log(`Skipping rest at index ${e} during scheduling (beat ${t.startBeat}, duration ${t.duration})`),this.scheduledNoteIndices.add(e);continue}this.scheduleNote(e),this.scheduledNoteIndices.add(e)}}scheduleNote(e){const t=this.notes[e],s=this.getLoopLength(),o=this.getLoopIterationForNote(e),i=o*s+t.startBeat,n=t.isChord?`chord [${t.notes.map(a=>a.note).join(", ")}]`:t.notes[0].note;console.log(`Scheduling note ${e} (${n}) at beat ${i.toFixed(3)} (loop ${o})`),this.metronome.scheduleAt(i-this.cueLeadTimeBeats,()=>this.onCueTime(t,e),`cue-${e}-${o}`),this.metronome.scheduleAt(i-this.timingToleranceBeats,()=>this.onWindowOpen(t,e),`window-open-${e}-${o}`),this.metronome.scheduleAt(i+this.timingToleranceBeats,()=>this.onWindowClose(t,e),`window-close-${e}-${o}`)}getLoopLength(){if(this.notes.length===0)return 0;const e=this.notes[this.notes.length-1];return e.startBeat+e.duration}getLoopIterationForNote(e){return e>=this.currentNoteIndex?this.currentLoopIteration:this.currentLoopIteration+1}onCueTime(e,t){if(console.log(`[CUE] onCueTime called for noteIndex=${t}, currentIndex=${this.currentNoteIndex}, state=${this.state}, activeIndices=${Array.from(this.activeNoteIndices)}`),e.isRest){console.log(`[CUE] Skipping rest at index ${t}`);return}let s=this.currentNoteIndex;for(;s<this.notes.length&&this.notes[s].isRest;)s++;const o=t===s,i=this.state==="CUE_SHOWN"&&t>s&&e.startBeat===this.notes[s]?.startBeat;if(!o&&!i){console.log(`[CUE] Skipping - not current note (noteIndex=${t}, currentIndex=${s}, noteBeat=${e.startBeat}, currentBeat=${this.notes[s]?.startBeat})`);return}if(o&&this.state==="IDLE"&&(this.currentNote=e,this.state="CUE_SHOWN",this.activeNoteIndices.clear()),this.activeNoteIndices.add(t),e.isChord){console.log(`[CUE] Showing cue for chord with ${e.notes.length} notes (index ${t})`);for(const n of e.notes)console.log(`[CUE] Calling setCuePad for chord note: row=${n.position.row}, col=${n.position.col}, note=${n.note}`),this.grid.setCuePad(n.position.row,n.position.col)}else{const n=e.notes[0];console.log(`[CUE] Showing cue for ${n.note} at row=${n.position.row}, col=${n.position.col} (index ${t})`),this.grid.setCuePad(n.position.row,n.position.col)}}onWindowOpen(e,t){let s=this.currentNoteIndex;for(;s<this.notes.length&&this.notes[s].isRest;)s++;if(t!==s||this.state!=="CUE_SHOWN")return;this.state="WINDOW_OPEN";const o=e.isChord?`chord [${e.notes.map(i=>i.note).join(", ")}]`:e.notes[0].note;console.log(`Timing window opened for ${o}`)}onWindowClose(e,t){let s=this.currentNoteIndex;for(;s<this.notes.length&&this.notes[s].isRest;)s++;if(t===s&&this.state==="WINDOW_OPEN"){const o=e.isChord?`chord [${e.notes.map(i=>i.note).join(", ")}]`:e.notes[0].note;console.log(`Timing window missed for ${o} - entering wait state`),this.enterWaitingState()}}handleNoteInput(e,t){if(!this.currentNote)return;let s=null;for(const r of this.activeNoteIndices){const c=this.notes[r];if(c.notes.find(d=>d.midiNote===t)){s=c;break}}if(!s){const r=[];for(const c of this.activeNoteIndices)r.push(...this.notes[c].notes.map(l=>l.note));console.log(`Wrong note played (${e}), expecting ${r.join(", ")}`);return}this.pressedNotesInChord.add(t);const o=[];for(const r of this.activeNoteIndices){const c=this.notes[r];o.push(...c.notes.map(l=>l.midiNote))}if(console.log(`✓ Note ${e} pressed (${this.pressedNotesInChord.size}/${o.length} total)`),!o.every(r=>this.pressedNotesInChord.has(r)))return;const n=this.grid.getActiveMidiNotes();if(!o.every(r=>n.includes(r))){console.log("⚠ Not all notes held simultaneously - keep holding!");return}console.log("✓ All simultaneous notes played correctly!"),this.pressedNotesInChord.clear(),this.state==="WINDOW_OPEN"?(console.log("✓ Correct note played in timing window!"),this.advanceToNextNote()):this.state==="WAITING"?(console.log("✓ Correct note played, resuming from wait state"),this.resumeFromWaiting()):this.state==="CUE_SHOWN"&&console.log("Note played too early (cue shown but window not open yet)")}advanceToNextNote(){this.grid.clearAllCuePads(),this.pressedNotesInChord.clear();for(const n of this.activeNoteIndices)this.scheduledNoteIndices.delete(n);const e=Array.from(this.activeNoteIndices),t=Math.max(...e),s=Math.min(...e);let o=(t+1)%this.notes.length,i=0;for(;i<this.notes.length&&this.notes[o].isRest;)console.log(`Auto-advancing past rest at index ${o}`),this.scheduledNoteIndices.delete(o),o=(o+1)%this.notes.length,i++;this.currentNoteIndex=o,this.currentNoteIndex<=s&&t===this.notes.length-1&&(this.currentLoopIteration++,console.log(`Loop iteration ${this.currentLoopIteration} starting`)),this.activeNoteIndices.clear(),this.scheduleNextNotes(),this.state="IDLE",this.currentNote=null}enterWaitingState(){this.state="WAITING",this.metronome.pause(),this.pressedNotesInChord.clear(),this.grid.flashMissedCue()}resumeFromWaiting(){this.grid.clearAllCuePads(),this.metronome.resume(),this.advanceToNextNote()}isPlaying(){return this.isActive}getTempo(){return this.metronome.getTempo()}setTempo(e){this.metronome.setTempo(e)}getMetronome(){return this.metronome}setMetronomeEnabled(e){this.metronome.setClickEnabled(e)}isMetronomeEnabled(){return this.metronome.isClickEnabled()}setMetronomeVolume(e){this.metronome.setClickVolume(e)}getMetronomeVolume(){return this.metronome.getClickVolume()}debugAdvance(){if(this.state==="IDLE"){let t=this.currentNoteIndex;for(;t<this.notes.length&&this.notes[t].isRest;)t++;if(t>=this.notes.length){console.log("[DEBUG] No more notes to play (all remaining are rests)");return}console.log("[DEBUG] State is IDLE, waiting for cue (next note at index "+t+")");return}if(!this.currentNote){console.log("[DEBUG] No active note to advance from");return}const e=this.currentNote.isChord?`chord [${this.currentNote.notes.map(t=>t.note).join(", ")}]`:this.currentNote.notes[0].note;console.log(`[DEBUG] Simulating successful play of ${e} in state ${this.state}`),this.state==="WAITING"&&(console.log("[DEBUG] Resuming from waiting state"),this.grid.clearAllCuePads(),this.metronome.resume()),this.advanceToNextNote(),console.log("[DEBUG] Advanced to next note (now at index "+this.currentNoteIndex+")")}}export{m as LearningModeService};
